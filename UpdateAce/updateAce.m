//
//  main.m
//  UpdateAce
//
//  Created by Alex Gray on 10/24/13.
//  Copyright (c) 2013 Code of Interest. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <Cocoa/Cocoa.h>
#import <JavaScriptCore/JavaScriptCore.h>

NSString *stringByPaddingTheLeftToLength(NSString *self, NSUInteger newLength) {
	for (int i = 0; i < self.length - newLength; i++) self = [NSString stringWithFormat:@" %@", self]; return self;
}

NSString *evaluateStringWithStringOrFile(NSString *command, id script){ JSStringRef resultStringJS; CFStringRef resultString; NSError *e; 

	NSString *theScript =
		([script isKindOfClass:NSString.class] || [script isKindOfClass:NSURL.class]) 
	&& [NSFileManager.defaultManager fileExistsAtPath:[script isKindOfClass:NSURL.class] ? [script path] : script isDirectory:NULL] 
	?	[NSString stringWithContentsOfFile:[script isKindOfClass:NSURL.class] ?[script path] : script  encoding:NSUTF8StringEncoding error:&e]
	:	[script isKindOfClass:NSString.class] ? script : nil;
	if (!theScript || e) return NSLog(@"error: %@", e), nil;
	
	theScript = [theScript stringByAppendingString:command];
	JSGlobalContextRef ctx = JSGlobalContextCreate(NULL);		// Create JavaScript execution context.
	JSStringRef scriptJS = JSStringCreateWithCFString((__bridge CFStringRef)theScript); 	// Evaluate script.
	JSValueRef result 	= JSEvaluateScript(ctx, scriptJS, NULL, NULL, 0, NULL);
	JSStringRelease(scriptJS);
	if (result) resultStringJS = JSValueToStringCopy(ctx, result, NULL);		// Convert result to string, unless result is NULL.
	resultString = result ? JSStringCopyCFString(kCFAllocatorDefault, resultStringJS) : CFSTR("[Exception]");
	if (result) JSStringRelease(resultStringJS);
	JSGlobalContextRelease(ctx);		// Release JavaScript execution context.
	return (__bridge NSString*)resultString;	// Return result.
}



int main(int argc, const char * argv[])
{
	
	@autoreleasepool { 	NSError *e;

	NSString *cmd 	= @"Object.keys(supportedModes);", *srcRoot = [NSString stringWithUTF8String:getenv("SRCROOT")],
				*ACEModes = [NSString stringWithFormat:@"%@/ACEView/Source/Utilities/Headers/ACEModes.h", srcRoot],
				*ACEModeArrays = [NSString stringWithFormat:@"%@/ACEView/Source/Utilities/ACEModeArrays.m", srcRoot],
				*file = [NSString stringWithFormat:@"%@/ACEView/Dependencies/ace/build/src/ext-modelist.js", srcRoot],
		   *parsable =  [[NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil]
								  stringByTrimmingCharactersInSet:NSCharacterSet.whitespaceAndNewlineCharacterSet];
								  
	NSRange firstInstance = [parsable rangeOfString:@"var supportedModes"];
	parsable = [parsable substringFromIndex:firstInstance.location];
	NSRange closingBrace = [parsable rangeOfString:@"};"];
	parsable = [parsable substringWithRange:NSMakeRange(0,closingBrace.location + 2)];

	NSArray *humanReadables = [evaluateStringWithStringOrFile(cmd, 	 parsable) componentsSeparatedByString:@","];
	
	NSString*(^getShorty)(NSString *) = ^NSString*(NSString *key) {
		NSString * res = evaluateStringWithStringOrFile([NSString stringWithFormat:@"supportedModes.%@;", key],
																		 parsable);
		NSRange r = [res rangeOfString:@"|"];
		return [res substringToIndex:r.location == NSNotFound ? res.length : r.location];
	};
	NSString *autogenHeader = @"/*** This file... ACEModeNamesAutoGenerated.h is AUTOGENERATED.  See target 'UpdateAce'*/\n\n";	

/*	[[NSString stringWithFormat:
@"%@ \
typedef NS_ENUM (NSUInteger, ACEMode) {\n\n \
\tACEMode%@,\n\n \
\
\tACEModeCount  // keep track of the enum size automatically\n \
};\n\n", autogenHeader, [humanReadables componentsJoinedByString:@",\tACEMode"]]writeToFile:ACEModes atomically:YES encoding:NSUTF8StringEncoding error:&e];
	NSLog(@"writing to:%@.  Errors? :%@", ACEModes, e);	
*/

	[[NSString stringWithFormat:
@"%@ \
@interface ACEModeNameTransformer : NSValueTransformer @end

@interface ACESetting : NSObject 	@property (strong) NSString *name;	@end
@interface   ACETheme : ACESetting	@property 			 ACETheme  mode;	@end
@interface    ACEMode : ACESetting	@property 			  ACEMode  mode;	@end

@interface ACEMode%@ \
@interface ACEModes : NSArrayController @end", autogenHeader, [humanReadables componentsJoinedByString: @" : ACEMode @end\n@interface ACEMode"]]writeToFile:ACEModes atomically:YES encoding:NSUTF8StringEncoding error:&e];

	NSLog(@"writing to:%@.  Errors? :%@", ACEModes, e);	
	
	
	__block NSMutableString *generated = 	[NSMutableString stringWithFormat:
@"%@ \
NSString *const _ACEModeNames[ACEModeCount] = {\n\n ", autogenHeader];

	[humanReadables enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
		[generated appendString:stringByPaddingTheLeftToLength([NSString stringWithFormat:@"[ACEMode%@]", obj], 23)];
		[generated appendFormat:@" = @\"%@\"%@", getShorty(obj), idx<humanReadables.count-1 ? @",\n" : @"\n};\n\n"];
	}];
	
	[generated  appendString:@"\n\nNSString *const _ACEModeNamesHuman[ACEModeCount] = {\n"];
	[humanReadables enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
		[generated appendString:stringByPaddingTheLeftToLength([NSString stringWithFormat:@"[ACEMode%@]", obj], 23)];
		[generated appendFormat:@" = @\"%@\"%@", obj,idx<humanReadables.count-1 ? @",\n" : @"\n};\n"];
	}];

	[generated writeToFile:ACEModeArrays atomically:YES encoding:NSUTF8StringEncoding error:&e];
	NSLog(@"writing to:%@.  Errors? :%@", ACEModeArrays, e);	
//	NSLog(generated);

////    [ACEModeASCIIDoc]			 = @"ASCII Doc",
////	NSString *const _ACEModeNames[ACEModeCount] = {
//    [ACEModeASCIIDoc]			 = @"asciidoc",


//	NSMutableArray *lines = [componentsSeparatedByString:@"\n"].mutableCopy;
//	[lines.copy enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
//		if ([obj rangeOfString:@"var supportedModes"].location == NSNotFound) [lines removeObjectAtIndex:0];
//		else *stop = YES;
//	}];
//	[lines.copy enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
//	
//	}];
//	[lines removeObjectAtIndex:lines.count-1];

	//,//",
		//																	));
		
		//		WebScriptObject *obj = (WebScriptObject *)JSArray;
		//
		//		NSUInteger count = [[obj valueForKey:@"length"] integerValue];
		//		NSMutableArray *a = [NSMutableArray array];
		//		for (NSUInteger i = 0; i < count; i++) {
		//			NSString *item = [obj webScriptValueAtIndex:i];
		//			if ([item isKindOfClass:[NSString class]]) {
		//			[a addObject:item];
		//		}
		//}
		
		// insert code here...
//		[NSApp run];
		
	}
	return 0;
}



//- (void) setScript:(WebScriptObject *)script {
//	_script = script;
//	NSLog(@"script changed.. %@", [script evaluateWebScript:@"print supportedModes;"]);
//}
//- (id) initWithFile:(NSString *)file { if (!(self = super.init)) return  nil;
//	
//	self.frameLoadDelegate = self;
//	NSString *s = [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil];
//	[self.mainFrame loadHTMLString:s baseURL:nil];
//	self.script = [self windowScriptObject];
//	//	self.mainFrameURL = [path];
//	//	[self bind:@"script" toObject:self.mainFrame withKeyPath:@"windowObject" options:nil];
//	return self;
//}
//
//
//@end
